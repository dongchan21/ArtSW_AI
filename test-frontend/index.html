<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>문제 보기</title>
</head>
<body>
  <h1>문제 선택</h1>
  <div id="problemList"></div>

  <h2>프롬프트 제출</h2>
  <form id="promptForm">
    <label for="problemId">선택된 문제 ID:</label><br>
    <input type="text" id="problemId" name="problemId" readonly><br><br>

    <label for="userPrompt">사용자 프롬프트:</label><br>
    <textarea id="userPrompt" name="userPrompt" rows="4" cols="50"></textarea><br><br>
    <button type="submit">제출</button>

    <button id="runEvalBtn" type="button">실행 + 평가</button>

    <h2>사용자 프롬프트 출력</h2>
    <pre id="stream-user-output" style="background:#222;color:#0f0;padding:10px;white-space:pre-wrap;min-height:120px;"></pre>

    <h2>레퍼런스 프롬프트 출력</h2>
    <pre id="stream-ref-output" style="background:#222;color:#0ff;padding:10px;white-space:pre-wrap;min-height:120px;"></pre>

    <button id="sequentialStreamBtn" type="button">순차 스트리밍 (사용자 → 레퍼런스)</button>



  </form>

  <h2>평가 결과</h2>
  <pre id="problem-detail" style="background:#f5f5f5; padding:10px;"></pre>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
    // 1. 문제 리스트 받아오기
    fetch("http://localhost:8000/api/problems")
      .then(response => response.json())
      .then(data => {
        const problemListDiv = document.getElementById("problemList");
        Object.entries(data).forEach(([problemId, problem]) => {
          const button = document.createElement("button");
          button.innerText = `${problemId}: ${problem.title}`;
          button.onclick = () => {
            document.getElementById("problemId").value = problemId;
          };
          problemListDiv.appendChild(button);
          problemListDiv.appendChild(document.createElement("br"));
        });
      });

    // 2. 폼 제출 핸들러
    document.getElementById("promptForm").addEventListener("submit", function(event) {
      event.preventDefault();

      const problemId = document.getElementById("problemId").value;
      const userPrompt = document.getElementById("userPrompt").value;

      if (!problemId) {
        alert("먼저 문제를 선택하세요.");
        return;
      }

      fetch("http://localhost:8000/api/submit_prompt", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ problem_id: problemId, user_prompt: userPrompt })
      })
      .then(response => response.json())
      .then(data => alert(data.message))
      .catch(error => console.error("Error:", error));
    });

//   document.getElementById("evaluateBtn").addEventListener("click", function () {
//   const problemId = document.getElementById("problemId").value;
//   const userPrompt = document.getElementById("userPrompt").value;

//   if (!problemId || !userPrompt) {
//     alert("문제 선택과 프롬프트 입력이 모두 필요합니다.");
//     return;
//   }

//   fetch("http://localhost:8000/api/evaluate_prompt", {
//     method: "POST",
//     headers: {
//       "Content-Type": "application/json"
//     },
//     body: JSON.stringify({ problem_id: problemId, user_prompt: userPrompt })
//   })
//   .then(res => res.json())
//   .then(data => {
//     alert(
//   `평가 점수: ${data.score} / ${data.total}\n\n피드백:\n` + data.feedback
// );
//   })
//   .catch(err => console.error("평가 실패:", err));
// });

document.getElementById("runEvalBtn").addEventListener("click", async () => {
    const problemId = document.getElementById("problemId").value;
    const userPrompt = document.getElementById("userPrompt").value;
    if (!problemId || !userPrompt) {
      alert("문제 선택과 프롬프트 입력이 필요합니다.");
      return;
    }
    const res = await fetch("http://localhost:8000/api/run_and_evaluate", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({ problem_id: problemId, user_prompt: userPrompt, mode: "evaluation" })
    });
    const data = await res.json();
    // 결과 출력 (간단 버전)
    const pretty = JSON.stringify(data, null, 2);
    document.getElementById("problem-detail").textContent = pretty;
    alert(`LLM 총점: ${data.llm_eval?.overall_score ?? "N/A"} / 100`);
  });
});

document.addEventListener("DOMContentLoaded", () => {

  // 스트리밍 유틸: 필요하면 4번째 인자로 버퍼 변수명 전달
  async function runStream(endpoint, body, outElId, captureBufferVar = null) {
    const outEl = document.getElementById(outElId);
    outEl.textContent = "";
    if (captureBufferVar) window[captureBufferVar] = "";

    const res = await fetch(endpoint, {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(body),
    });
    if (!res.ok || !res.body) {
      outEl.textContent = `HTTP ${res.status} 에러`;
      return;
    }

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
      const { value, done } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const parts = buffer.split("\n\n");
      buffer = parts.pop() || "";

      for (const part of parts) {
        if (!part.startsWith("data:")) continue;
        const data = part.slice(5).trim();
        if (data === "[DONE]") return;

        try {
          const json = JSON.parse(data); // { delta: "..." }
          if (json.delta) {
            outEl.textContent += json.delta;
            if (captureBufferVar) window[captureBufferVar] += json.delta;
          }
        } catch {}
      }
    }
  }


  // 순차 실행: 사용자 → 끝나면 레퍼런스(문제의 reference_prompt 사용)
    // 고급: 스트리밍 도중 평가 미리 걸기
  document.getElementById("sequentialStreamBtn").addEventListener("click", async () => {
    const problemId = document.getElementById("problemId").value;
    const userPrompt = document.getElementById("userPrompt").value;
    if (!problemId || !userPrompt) {
      alert("문제 선택과 프롬프트 입력이 필요합니다.");
      return;
    }

    // (A) 사용자 스트림 시작과 동시에 레퍼런스 전체 텍스트 비동기 요청 시작
    const refFullPromise = fetch("http://localhost:8000/api/chat/generate_reference_full", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ problem_id: problemId })
    }).then(r => r.json()).catch(e => ({ reference_output: "" }));

    // 사용자 출력 스트리밍 + 전체 텍스트 캡처
    await runStream(
      "http://localhost:8000/api/chat/stream_user",
      { problem_id: problemId, user_prompt: userPrompt },
      "stream-user-output",
      "USER_BUFFER"
    );

    // (B) 사용자 스트림이 끝난 시점에, ref 전체 텍스트 확보
    const refJson = await refFullPromise;
    const referenceFullText = refJson?.reference_output ?? "";

    // (C) 평가만 수행하는 요청을 바로 걸어둠 (백그라운드 진행)
    const evaluatePromise = fetch("http://localhost:8000/api/run_evaluate_only", {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({
        problem_id: problemId,
        user_prompt: userPrompt,
        user_output: window.USER_BUFFER || "",
        reference_output: referenceFullText,
        mode: "evaluation"
      })
    }).then(r => r.json()).catch(err => ({ error: String(err) }));

    // (D) 화면에는 레퍼런스도 '순차'로 스트리밍해서 보여줌 (평가와 병렬로 진행)
    await runStream(
      "http://localhost:8000/api/chat/stream_reference_by_problem",
      { problem_id: problemId },
      "stream-ref-output",
      "REF_BUFFER_UI" // 화면용 캡처(선택)
    );

    // (E) 평가 결과 수신 → 점수/피드백만 요약해서 표시 (프롬프트/답변 본문 제외)
    const evalData = await evaluatePromise;
    const summary = {
      score: evalData?.llm_eval?.overall_score ?? null,
      quality: evalData?.llm_eval?.quality ?? null,
      techniques_used: evalData?.llm_eval?.techniques_used ?? [],
      missing_techniques: evalData?.llm_eval?.missing_techniques ?? [],
      feedback: evalData?.llm_eval?.feedback ?? "",
      heuristic: evalData?.heuristic ?? {}
    };
    document.getElementById("problem-detail").textContent =
      JSON.stringify(summary, null, 2);
  });

}); // ← DOMContentLoaded 닫기

  </script>

</body>
</html>
