<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>문제 보기</title>
</head>
<body>
  <h1>문제 선택</h1>
  <div id="problemList"></div>

  <h2>프롬프트 제출</h2>
  <form id="promptForm">
    <label for="problemId">선택된 문제 ID:</label><br>
    <input type="text" id="problemId" name="problemId" readonly><br><br>

    <label for="userPrompt">사용자 프롬프트:</label><br>
    <textarea id="userPrompt" name="userPrompt" rows="4" cols="50"></textarea><br><br>
    <button type="submit">제출</button>

    <button id="runEvalBtn" type="button">실행 + 평가</button>

    <!-- 폼 안, runEvalBtn 옆에 하나 추가 -->
    <button id="streamBtn" type="button">스트리밍 실행</button>

    <!-- 아래 평가 결과 영역과 별도로, 스트리밍 출력 전용 -->
    <h2>스트리밍 출력</h2>
    <pre id="stream-output" style="background:#111;color:#0f0;padding:10px;white-space:pre-wrap;min-height:120px;"></pre>

  </form>

  <h2>평가 결과</h2>
  <pre id="problem-detail" style="background:#f5f5f5; padding:10px;"></pre>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
    // 1. 문제 리스트 받아오기
    fetch("http://localhost:8000/api/problems")
      .then(response => response.json())
      .then(data => {
        const problemListDiv = document.getElementById("problemList");
        Object.entries(data).forEach(([problemId, problem]) => {
          const button = document.createElement("button");
          button.innerText = `${problemId}: ${problem.title}`;
          button.onclick = () => {
            document.getElementById("problemId").value = problemId;
          };
          problemListDiv.appendChild(button);
          problemListDiv.appendChild(document.createElement("br"));
        });
      });

    // 2. 폼 제출 핸들러
    document.getElementById("promptForm").addEventListener("submit", function(event) {
      event.preventDefault();

      const problemId = document.getElementById("problemId").value;
      const userPrompt = document.getElementById("userPrompt").value;

      if (!problemId) {
        alert("먼저 문제를 선택하세요.");
        return;
      }

      fetch("http://localhost:8000/api/submit_prompt", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ problem_id: problemId, user_prompt: userPrompt })
      })
      .then(response => response.json())
      .then(data => alert(data.message))
      .catch(error => console.error("Error:", error));
    });

//   document.getElementById("evaluateBtn").addEventListener("click", function () {
//   const problemId = document.getElementById("problemId").value;
//   const userPrompt = document.getElementById("userPrompt").value;

//   if (!problemId || !userPrompt) {
//     alert("문제 선택과 프롬프트 입력이 모두 필요합니다.");
//     return;
//   }

//   fetch("http://localhost:8000/api/evaluate_prompt", {
//     method: "POST",
//     headers: {
//       "Content-Type": "application/json"
//     },
//     body: JSON.stringify({ problem_id: problemId, user_prompt: userPrompt })
//   })
//   .then(res => res.json())
//   .then(data => {
//     alert(
//   `평가 점수: ${data.score} / ${data.total}\n\n피드백:\n` + data.feedback
// );
//   })
//   .catch(err => console.error("평가 실패:", err));
// });

document.getElementById("runEvalBtn").addEventListener("click", async () => {
    const problemId = document.getElementById("problemId").value;
    const userPrompt = document.getElementById("userPrompt").value;
    if (!problemId || !userPrompt) {
      alert("문제 선택과 프롬프트 입력이 필요합니다.");
      return;
    }
    const res = await fetch("http://localhost:8000/api/run_and_evaluate", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({ problem_id: problemId, user_prompt: userPrompt, mode: "evaluation" })
    });
    const data = await res.json();
    // 결과 출력 (간단 버전)
    const pretty = JSON.stringify(data, null, 2);
    document.getElementById("problem-detail").textContent = pretty;
    alert(`LLM 총점: ${data.llm_eval?.overall_score ?? "N/A"} / 100`);
  });
});

document.addEventListener("DOMContentLoaded", () => {
  // ... (당신의 기존 코드들: 문제 목록 fetch, submit, runEvalBtn 등)

  // --- 스트리밍: 상태 및 유틸 ---
  let currentStreamAbort = null;

  function appendStreamText(text) {
    const el = document.getElementById("stream-output");
    el.textContent += text;
    // 자동 스크롤
    el.scrollTop = el.scrollHeight;
  }

  function resetStreamOutput() {
    const el = document.getElementById("stream-output");
    el.textContent = "";
  }

  // --- 스트리밍 버튼 핸들러 ---
  document.getElementById("streamBtn").addEventListener("click", async () => {
    const problemId = document.getElementById("problemId").value;
    const userPrompt = document.getElementById("userPrompt").value;

    if (!problemId || !userPrompt) {
      alert("문제 선택과 프롬프트 입력이 필요합니다.");
      return;
    }

    // 이전 스트림이 돌고 있으면 중단
    if (currentStreamAbort) {
      currentStreamAbort.abort();
      currentStreamAbort = null;
    }

    resetStreamOutput();
    appendStreamText("▶ 스트리밍 시작...\n");

    // AbortController로 중단 가능하게
    const ac = new AbortController();
    currentStreamAbort = ac;

    try {
      // 필요하다면 메시지에 problemId를 함께 보낼 수 있음
      const res = await fetch("http://localhost:8000/api/chat/stream", {
        method: "POST",
        headers: {"Content-Type": "application/json"},
        body: JSON.stringify({
          model: "gpt-4o-mini",
          messages: [
            { role: "system", content: "You are a helpful assistant." },
            // 문제 컨텍스트를 넣고 싶으면 title/desc를 서버에서 받아와 넣어도 좋음
            { role: "user", content: userPrompt }
          ]
        }),
        signal: ac.signal
      });

      if (!res.ok || !res.body) {
        appendStreamText(`\n[에러] HTTP ${res.status}`);
        return;
      }

      const reader = res.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";

      // 본격 스트리밍 루프
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });

        // SSE는 공백줄(\n\n) 단위로 분리됨
        const parts = buffer.split("\n\n");
        buffer = parts.pop() || ""; // 마지막 덜 온 청크는 버퍼에 남김

        for (const part of parts) {
          // "data: ..." 라인만 처리
          const line = part.split("\n").find(l => l.startsWith("data:"));
          if (!line) continue;
          const data = line.slice(5).trim(); // 'data:' 제거

          if (data === "[DONE]") {
            appendStreamText("\n\n■ 스트리밍 종료");
            currentStreamAbort = null;
            return;
          }

          try {
            const json = JSON.parse(data); // { delta: "..." }
            if (json.delta) appendStreamText(json.delta);
          } catch (e) {
            // 파싱 실패 시, 원문 그대로 찍어보기
            appendStreamText(`\n[WARN raw] ${data}`);
          }
        }
      }

      appendStreamText("\n\n■ 스트림 완료");
    } catch (err) {
      if (err.name === "AbortError") {
        appendStreamText("\n\n■ 스트림 중단됨");
      } else {
        appendStreamText(`\n\n[에러] ${err}`);
      }
    } finally {
      currentStreamAbort = null;
    }
  });

}); 

  </script>

</body>
</html>
